ADITYA UNIVERSITY COMPITITIVE PROGRAMMING

DAY1 MONDAY 09-06-2025
SESSION1:
APP INSTALLATIONS:
Note: 
1. Prefer installing the installer files (.msi)
2. Once the installer file is downloaded, cut and paste it in the respective folder inside the software folder in C drive.
3. Then double click the installer and install the app/software

Create 2 folders named:
"software" in C drive
"learning" in D/E/C drive

Inside the software folder creates the folders named:
notepad_pp
vs_code
eclipse
git
jdk
intellij

1. Notepad++:	For making quick notes
G Search: Download notepad++
Link: https://notepad-plus-plus.org/downloads/v8.7.7/

2. vs code
G Search: Download vs code
Link: https://code.visualstudio.com/download

3. Eclipse
G Search: Download eclipse
From the link: https://www.eclipse.org/downloads/
Click on download packages
Link: https://www.eclipse.org/downloads/packages/
Download: Eclipse IDE for Enterprise Java and Web Developers (Select the OS)

4. git
G search: Download git
Link: https://git-scm.com/downloads
Click on the OS running on your system

5. JDK
G Search: Download JDK 17
Link: https://www.oracle.com/java/technologies/javase/jdk17-archive-downloads.html
Click on: Windows x64 Installer	153.92 MB

GITHUB:
1. Create Git Account and Login
2. Create a new Repo for our training
	Click on the + symbol on top, now click create new repo
	In the new page, enter the repo name
	Enter a suitable note/description for the repo
	Keep the Repo public
	Select the check box add readme file
	Now click on the create repository (green color) button
3. Create Personal Access Token (PAT)
	Click on profile icon (Top right corner)
	Click settings
	In new windown scroll down and on left, click developer settings
	In new window, on top right, click personal access tokens, select Tokens classic
	In new window, click generate new token, select generate new token classic
	In window, add suitable note
	Click Expiration, selecty No expiry
	Under Scope, select only the 1st (top most) check box named "Repo"
	Now fully scroll down and click Generate PAT
	Now Copy the PAT (Click the copy button)
	Now mail the PAT to yourself (confidentiality) [Use the mail subject as "git pat"]
4. Configuration commands (To link our git account on the system we working)
	$ git config --global user.name "USERNAME"
	
	$ git config --global user.email "EMAIL"

TRAINER REPO LINK:
https://github.com/neelmyna/java_dsa

To Download/Clone/Copy the TRAINER REPO. Use the command:
$ git clone https://github.com/neelmyna/java_dsa

SESSION2:
To Copy A Repo into our system (Laptop):
$ git clone Repo_Link
$ git clone https://github.com/neelmyna/java_dsa

The above command copies the given Repo into out computer. The Copy of the Repo in the Server (github) can be called as Remote Repo and the copy of the Repo in our computer can be called as Local Repo.

Template:
$ git clone https://<PAT>@Repo_Link

Example:
$ git clone https://hefbkljwhfgklerhkjgvfhefkjvbdkfjb@github.com/neelmyna/java_dsa

The above command in which we have cloned a Repo using PAT is to do the Push commands without having to authenticate everytime.

To Push content into the Remote Repo (server). That is to copy the content from Local Repo (from computer) to Remote Repo, the commands are:

Steps and Commands:
1st ask the git to list down all the files that need to be pushed (uploaded)

$ git add path
$ git add C:/learning/java_dsa
$ git add .

2nd Step: Ask the git to create a secured object in which all the files to be pushed are copied.

$ git commit -m "java dsa notes added"

3rd Step: Push (upload) 
$ git push origin main
$ git push (Always pushes to main branch)

To check the status of the repo
$ git status
-----------------------------
To create a new project in eclipse:

File -> New -> Project -> Java Project
In the Dialogue box (new window)
De-select the module.java check box
Enter project name ("practice") and Click Finish

Now in the explorer, expand the project folder
Now Right Click src folder -> create -> new -> package
Give the package name "day1"

Right Click "day1" in explorer (under src), create -> new -> class
Class name "HelloWorld"

primitive types in Java:
Numeric:
	number only
		byte
		short
		int 
		long
	number with precision/accuracy
		float
		double
char
boolean

ARITHMETIC OPERATORS:
+ - * / %

All the operators take 2 operands/input
Hence, all are binary operators
The expression is written using INFIX notation.
55 + 5
i/p are numbers
o/p is also a number
5 + 8 / 9
The division must be evaluated 1st. Boadmas rule
3 + 5 - 9
All Arithmetic operators have Left to Right Associtivity.
The Infix expression is what we users use. But it will be 1st converted to postfix expression and only then it is evaluated.

int num = 45;
00000000 00000000 00000000 00101101
00101101

int num = -45;

00101101
11010010
11010011
-1*2(7) + 1 * 2(6) + 1 * 2(4) + 3
-128 + 64 + 16 + 3
= -64 + 19
= -45

float num = 5.5;

sum = 55 + (-50) + 5.5
sum = 5 + 5.5
When the expression has operands of different types, then the lower sized DT value is converted to a value of higher sized DT, and only then the expression is solved. This is because the data must not be lost (decimal part of the number)
----------------------------------
DAY2 11-06-2025 WEDNESDAY
Java languages basics

Relational Operators:
> < >= <= != ==

I/P are numbers
O/P is boolean
All are binary operators
Used with Infix notation
Has lesser precedence than Arithmetic operators
Has higher precedence than logical operators

for i from 1 to n do:
for(int i = 1; i <= n; i++)
for(int i = 1; i < n+1; i++)

for(int i = 1; i <= 20; i++)
for(int i = 1; i < 21;  i++)

[10, 40]	closed interval 10 to 40
(20, 30)	open interval 21 to 29
[35, 65)	Right Open 35 to 64

i = 10;
j = 5;
i++;
j--;
a[i] = b[j]
b[j]--;

i = 10;
j = 5;
a[++i] = b[--j]--;
-------------------------------------
Logical Operators:
& && | || !

I/P are boolean
O/P is boolean
All are binary operators expect the not operator
Used with Infix notation
Has lesser precedence than Arithmetic operators and relational but has higher precedence than assignment operator.

The Post increment and Post decrement operators have lesser precedence than the assignment operator.

The dot operator
object.field
Paranthesis has the highest priority.
It is not an operators, but used to override the precedence of an operators.

JAVA PROGRAM STRUCTURE:

DISADVANTAGES OF C++:
main() must be a global function.
Global functions were allowed. Thus the solutions (apps.software) created with neither procedural nor OO.
global variables are still allowed in C++.
Files are loaded using macros and stored till end of the program
pointers were always a mess to many a programmers
The onus of creating and deleting objects in the Heap is on programmer.
The inheritance is by default private which makes the accessing the inherited properties very difficult.
Multiple inheritance creates a solution which is low cohesive.
The operator overloading concept can be used to just implement anything which is unnecessary
The compiler creates object file which is environment restricted/specific/dependent.
Handling  runtime errors is difficult.
Objects can be created in Stack area as well.
Array is primitive in C++

Java:
No global functions. All are only methods. So you have strict OO solution.
No global variables.
signed and unsigned removed. Thus the primitive DTs are simplified.
libraries can be loaded and used dynamically (No pre-processors)
Pointers are abstracted and users are given references.
All objects are created in Heap only
Array is an object in java
Creating object is the only job the programmer does. Object deletion is automated with the concept GRABAGE COLLECTOR.
The inheritance is always public in Java
There is no Multiple inheritance. All classes are always High cohesive. Thus the implementation is very easy.
The only operator that can be overloaded is + and only for string concatination.
The compiler creates bytecode which is environment(OS) independent.
Handling  runtime errors is easy via exception Handling.
The friend concept is removed. Thus no more ambiguous and complex classes.
------------------
public static void main(String[] args) {
		int num1 = 10;
		int num2;
		num1 = 45;
		num2 = 35;
		System.out.println("Num1="+num1+", Num2="+num2); // Implicitly num1 and num2 are converted to strings using toString()
		float num = 5.5; // Error 5.5 is double and num is float (implicit down cast)
		float num = (float) 5.5;
		int sum = num1 + num; // Error, num1+num is float but sum is int
	}
-------------------------------------------------------
DAY3 FRIDAY 13-06-2025

package day1;

import java.util.Objects;

public class Flight {
	private int id = 111;
	private String airline = "SpiceJet";
	private String source = "Chennai";
	private String destination = "Hyderabad";
	private float fare = 3500;
	private float duration = 1.5f;
	
	{
		System.out.println("From the Instance Initializer Block");
		System.out.println(this.id);
		System.out.println(airline);
		System.out.println(source);
		System.out.println(destination);
		System.out.println(fare);
		System.out.println(duration);
		System.out.println("----------------------------");
		// Now we shall change the values
		this.id = 1234;
		this.airline = "Akasa";
		this.source = "Vishakapatnam";
		this.destination = "Srinagar";
		this.fare = 8900;
		this.duration = 3.5f;
	}
	
	public Flight() {
		
	}

	public Flight(int id, String airline, String source, String destination, float fare, float duration) {
		super();
		System.out.println("From the All Arg Cons");
		System.out.println(this.id);
		System.out.println(this.airline);
		System.out.println(this.source);
		System.out.println(this.destination);
		System.out.println(this.fare);
		System.out.println(this.duration);
		System.out.println("----------------------------");
		this.id = id;
		this.airline = airline;
		this.source = source;
		this.destination = destination;
		this.fare = fare;
		this.duration = duration;
	}

	public String getAirline() {
		return airline;
	}

	public void setAirline(String airline) {
		this.airline = airline;
	}

	public String getSource() {
		return source;
	}

	public void setSource(String source) {
		this.source = source;
	}

	public String getDestination() {
		return destination;
	}

	public void setDestination(String destination) {
		this.destination = destination;
	}

	public float getFare() {
		return fare;
	}

	public void setFare(float fare) {
		this.fare = fare;
	}

	public float getDuration() {
		return duration;
	}

	public void setDuration(float duration) {
		this.duration = duration;
	}

	public int getId() {
		return id;
	}

	@Override
	public String toString() {
		return "Flight [id=" + id + ", airline=" + airline + ", source=" + source + ", destination=" + destination
				+ ", fare=" + fare + ", duration=" + duration + "]";
	}

	@Override
	public int hashCode() {
		return Objects.hash(airline, destination, duration, fare, id, source);
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Flight other = (Flight) obj;
		return Objects.equals(airline, other.airline) && Objects.equals(destination, other.destination)
				&& Float.floatToIntBits(duration) == Float.floatToIntBits(other.duration)
				&& Float.floatToIntBits(fare) == Float.floatToIntBits(other.fare) && id == other.id
				&& Objects.equals(source, other.source);
	}
	
	public static void main(String[] args) {
		Flight flight2 = new Flight(1001, "AirIndia", "Bengaluru", "Delhi", 6900.5f, 3.15f);
		System.out.println("Flight details initialized by the User");
		System.out.println(flight2.id);
		System.out.println(flight2.airline);
		System.out.println(flight2.source);
		System.out.println(flight2.destination);
		System.out.println(flight2.fare);
		System.out.println(flight2.duration);
	}
}
----------------------------------------------------------
When an object is created during the runtime, 1st the control goes to declarative stmt. Secondly it goes to the instance initializer block (un-named block) ifd present. Then it goes into the respective constructor.

All local variables in Java are not initialized untill it is initialized by the programmer. Thus the local variables will be empty if they are not initialized. The 1st assignment to the local variables is its initializarion.

Unlike the local variables, the instance variables and the static (class) variables have default values.
byte, short, int and long instance variables have 0 as default values
float varlable would have 0.0f
double varlable would have 0.0
boolean instance or static variable will have false as default value
And if the instance or static variable is a reference type, then its default value will be null

The super() in the constructor will make call to immediate parent class sonstructor. And this call happens right at PROLOGUE of the child class constructor.
We can optionally pass args to super(). However in such a case 
------------------------------------------------------------------------------
1. Check if the given positive integer is a perfect square.

STEPS TO SOLVE A PROBLEM:

1. Understand the problem statement carefully and list the I/P data. List also the relavant information. Isolate the unwanted data or information. Ascertain what should be the O/P. Lastly, recognise the contraints.
Outcome: You get to know the straight forward Question.

2. Find a possible solution using what ever means. Trial and error method or using a spacific algorithm or formula. You may get multiple solutions as well. In such a case implement them one by one. Note that you have not even thought of programming or its concepts. Find solution mathematically.
Outcome: We got a solution

3. Write the Algorithm. Step by step procedure to solve the problem. Wehre each step is 
finite, unambigious and simple.
OutCome: You have a clearer solution via steps.

4. Verify your solution. Using flow chart or trace the algorithm step by step (Debugging)
OutCome: We have verified solution

5. Write the Fake code if necessary (Pseudocode)

6. Code it!

n = 145
145		12.05	12		144
49		7.0		7		49

math
round()
ciel()
floor()

Read the i/p, say N
Using the built in logic, find the sq root of N. Store it in a variable, say PERFECT_ROOT
Now, store the PERFECT_ROOT as integer number, say ROOT
Now multiply ROOT with itself and check if it is equal to N
If yes, then O/P N is PS
If no, then O/P N is not a PS

Read N
PERFECT_ROOT = math.sqrt(N)
ROOT = math.floor(PERFECT_ROOT)
if ROOT * ROOT is N then
	Print: N is PS
else
	Print: N is not a PS

package day1;

import java.util.Scanner;

/*
Read N
PERFECT_ROOT = math.sqrt(N)
ROOT = math.floor(PERFECT_ROOT)
if ROOT * ROOT is N then
	Print: N is PS
else
	Print: N is not a PS
*/
public class PerfectSquare {
	
	public static void main(String[] args) {
		int inputNumber = 0;
		Scanner scanner = new Scanner(System.in);
		System.out.print("Enter a number to check if it is a Perfect Square: ");
		inputNumber = scanner.nextInt();
		int rootNumber = (int)Math.sqrt(inputNumber);
		if(rootNumber * rootNumber == inputNumber) {
			System.out.println(inputNumber + " is a Perfect Square");
		}
		else {
			System.out.println(inputNumber + " is not a Perfect Square");
		}
	}
}
-----------------------------------------------------------------
The teacher has evaluated all the exam papers of the student Sushma. Help the coordinator to write/declare the exam result depending on the average marks. The coordinator gets the average marks from the teacher. The coordinator must check if the average score is valid or not. Any average score which is not mentioned in the below table is invalid.

0  to  59		Fail
60 to 80		Second class
81 to 95		First class
96 to 100		Outstanding

package day1;

import java.util.Scanner;

public class ExamResult {

	public static void main(String[] args) {
		float averageScore = 0.0f;
		Scanner scanner = new Scanner(System.in);
		System.out.print("Enter the student average score: ");
		averageScore = scanner.nextFloat();
		if(averageScore >= 0 && averageScore <= 59) {
			System.out.println("Result is Fail");
		}
		else if(averageScore <= 80) {
			System.out.println("Result is Second Class");
		}
		else if(averageScore <= 95) {
			System.out.println("Result is First Class");
		}
		else if(averageScore <= 100) {
			System.out.println("Result is Outstanding");
		}
		else {
			System.out.println("Invalid Score entered");
		}
		scanner.close();
	}
}
-------------------------------------------
Tax Calculation Problem based on 2025 Govt Norms.

Input data: name of the employee, location of the employee, designation of the employee, basic salary
HRA 15% of basic if employee lives in cosmopolitin city, semi urban city 10%, rural 5%
monthly bonus of 20% of basic salary
DA of 12% on basic salary

Level1:
Calculate the monthly salary without bonus
Calculate the monthly gross salary
Calculate the annual gross salary

Print employee details
Print monthly gross salary
Print annual gross salary
Print the bonus earned for the year

Level2:
The income tax slabs are as follows:
upto 5 lakhs: No Tax
5,00,001 to 8,00,000 10%
8,00,001 to 10,00,000 15%
10,00,001 to 12,00,000 20%
12,00,001 to 15,00,000 20%
15,00,001 to 20,00,000 25%
Above 20 Lakhs 30%

The Charity amount under 80G can be deducted from the gross salary
The interest paid on Home Loan of upto 1,20,000 can be claimed
Under the section 87, if eligible can claim upto 3 lakhs.

Print the taxable income

Level3:
Print employee details
Print salary details (basic, monthly gross, annual gross, annual bonus)
Print taxable income
Print total standard deductions
Print tax amount payable
------------------------------------------------------------
Farmer Problem Statement
Mahesh is a farmer and owns 80 acres of land. His land is equally divided into 5 segments. He grows
tomatoes in the 1st segment, potatoes in the 2nd segment, cabbage in the 3rd segment, sunflower in
the 4th segment and sugarcane in the 5th segment.
He is converting his land from chemical-driven farming to chemical-free farming. Mahesh starts with
the conversion of vegetables into chemical-free produce. He spends the first 6 months doing the same.
He then converts the sunflower land bank into chemical-free farming. This takes him another 4
months. Finally, he converts sugarcane into chemical-free farming over the next 4 months.
He gets a yield of the following for tomatoes. 30% of his tomato land gives him 10 tonne yield per acre.
The remaining 70% of his tomato land gives him 12 tonnes yield per acre. The selling price of tomato
is Rs. 7 per Kg.
The yield of potatoes is 10 tonnes per acre. He sells each kg at Rs. 20.
The yield of cabbage is 14 tonnes per acre. He sells each kg at Rs. 24.
The yield of sunflowers is 0.7 tonnes per acre. He sells each kg at Rs. 200.
The yield of sugarcane is 45 tonnes per acre. He sells each tonne at Rs. 4,000.
All the crops are sowed at the same time. Mahesh gets the above yield at the above-mentioned rate
in one crop cycle across his entire land of 80 acres.
What is
a. The overall sales achieved by Mahesh from the 80 acres of land.
b. Sales realisation from chemical-free farming at the end of 11 months?
---------------------------------------------------
DAY4 SATURDAY 14-06-2025

1. Find sum of the series 1 - n + n2 - n3 ..... M terms
0<=N<=5, 1<=M<=25

2. Find sum of Odd digits of a number.
2345
o/p: 8

3. Find sum of Even placed digits in a number.
9128735
o/p: 12
91827364
o/p: 10


45.0 / 7
6.4

45 // 7

q 6
r 3

2345
q 234
r 5

234
q 23
r 4

23
q 2
r 3

2
q 0
r 2

0 STOP
----------------------------
Week1 Student Feedbacl Link:
https://forms.gle/ZSeTzUx5Ka5hXHht7

if(count == 0 || tempNumber == 0)
    sumOfDigits = remainderDigit;

Arrays:
int a, b, c, d, e, f, ...t;
int[] array;
array = new int[10];

System.out.print()
Here System is a class from java.lang package
And out is a static reference variable of System class

public final class System {
    public static final PrintStream out;

    static {
        out = new PrintStream();
    }
}

final variable:
A variable once it is initialized (1st assignment) cannot be mutated. Thus final variables are read only variable.
A final variable can be both static and non static.
A final class is one which cannot be inherited/extended
A final method is one which cannot be overridden in the derived class.

Data Structure: Storing data and also arranging/organising it in memory in so specific way to archive some efficiency (space or time or simplicity) is data structure.

Array: An Array is a DS in which the elements of the array are stored in continuous memory locations.
There is no gap between any 2 cosecutive elements in an Array.
All elements of an array are of the same DT (same size).
Array in Java is an Object. Because the objects has the array itself and also the length variable in it.
Once the size of an array is fixed, it cannot be changed.
To delete an array, just make the reeference null.
An array is memory in-efficient DS.
An array is time efficient DS because the look-up is O(1)
Array is the most simple and primary DS.

Creating an Array in Java:

int array[10]; // Error
byte size = scanner.nextByte();
int[] array = new int[size];
int[] array = new int[5]{1, 2, 3, 4, 5}; // ERROR
int[] array = new int[]{1, 2, 3, 4, 5}; 
int[] array = {1, 2, 3, 4, 5};
--------------------------------------------
DAY5 MONDAY 16-06-2025

package day1;

public class ArrayExample {
	public static void main(String[] args) {
		int size = 10;
		int[] array;
		int[] array1 = new int[size];
		int[] array2 = new int[5]{1, 2, 3, 4, 5}; // ERROR
		int[] array3 = new int[]{1, 2, 3, 4, 5}; 
		int[] array4 = {1, 2, 3, 4, 5};
		
		int[][] matrix; // reference of type int[][]
		matrix = new int[3][]; // Array of 3 references of type int[]
		matrix[1] = new int[4]; // created an array of type int[] of size 4 and it pointed by the 2nd reference in array of type int[][]
		matirx[0] = new int[2]; // reference of type int[] is refrencing to the array of 2 int elements
		int _; // Error
		int 2d; // Error
		int _num; // fine
		int array2d; // good
	}
}

RELATIONSHIPS IN OOP:
Generalisation (Inheritance) is-a type-of
Association		has-a	part-of
	Aggregation (Weak or Optional association)
	Composition (Strong association)

Inheritance:
suv is-a car is-a vehicle

Aggregation:
	When the whole object existance is independent of the part object then it is aggregation
	When the part object (containee) and the whole object (container) can exist independent of eachother.
Composition:
	When the whole object existence is dependent on the part object existance.
	When the containee and container cannot exist independetn of eachother.

CONSTRUCTORS:
* A constructor is a instance method.
* It is called/invoked always implicitly (by the JVM) as soon as an object is created (Objects gets memory allocation. That means object's reference value is created)
* The object must have same name as that of the class so that the compiler/JVM knows which of the non static methods in the class are the constructors.
* We can define more than 1 constructor in class. Thus all the constructors must/will have same name. This concept is caleld as FUNCTION OVERLOADING.
* 
Assume there is class by name Flight
Flight() {

}

Flight(String code) {

}

main() { // Assume the systax is correct
	Flight flight = new Flight();
}

String calcBillAmount(int, float) {

}

int calcBillAmount(int, float) {

}

calcBillAmount(35, 45.5f);
* FUNCTION OVERLOADING:
-> Function Overloading is Compile time (static/early) binding/polymorphism.
-> Whcih of the overloaded method must be called is decided compiler.
-> The overloaded methods if have same arument list but different return types then it is an error. Because the change must be present at prologue and if the change is only present at epilogue.
-> The overloaded methods must differ in their argument list either by number of arguments or data type of the arguments, or if in case if both the number of arguments and their types are same then the order must be different.
* The job of a constructor is to initialize an object.
* A constructor cannot return a value ever. Thus its return type is always void. Now something which is always, in programming must be implicit. Because its always well known. Thus mentioning the return type for a constructor becomes redundant. And hence there must be no return type to a constructor.
* A constructor cannot static. Because a constructor is working for an object. And it is always has "this". Hence it cannot be static.
* Constructor is usually (99% of the cases) is public. However, they can be private also.
* Constructor cannot be final. Because all constructors are always final by nature. That is, suppose the constructor is overridden in the sub class, and we create an object of the base class, the overridden constructor in sub class becomes ALWAYS unreachable. Thus, constructors are by nature always are final. Hence it would be redundant to mark them final.
* Contructors cannot be abstract.Because 1st of all a class whose instance method is abstract its object cannot be created. Further, even if the constructor is defined in the derived class, we know it is unreacheble.

// Naming standard for read only variable:
private int final MAXIMUM_COUNT;

ABSTRACT CLASS:
* A class which has at least one abstract method must be marked abstract.
* A class having all methods defined can also be abstract.
* A class having all methods abstract (except constructors) is said to be 100% abstract.
* The derived class which inherits an abstract class can be a concrete class only if it defines all the abstract methods of the parent class and it itself doesnt declares any anstract method.
* If the derived class fails to define anyone of the abstract methods of the parent class then it itself must be marked abstract.
* An abstract class can still be used via its static members.

In Java:
public class B1 extends A1 {
	public B1(int x, int y) 
	{
		super(y);
		this.x = x;
	}
}

In C++:
class B1 : public A1 {
	public B1(int x, int y) : A1(y)
	{
		this.x = x;
	}
};
-----------------------------------------------------
Create a class to which only one onject can be created:

public class A1 {

}
public class User {
	A a1 = new A();
	A a2 = new A();
}


import java.util.Scanner;

class Person {
    private int id;
    private String name;
    private char gender;
    private String location;
    private static Person person;
    
    private Person() {
        System.out.println("Person object is created");
    }
    
    public static Person createPerson() {
        if (person == null) {
            person = new Person();
        }
        return person;
    }
    
    public void setPerson(int id, String name, char gender, String location) {
        this.id = id;
        this.name = name;
        this.gender = gender;
        this.location = location;
    }
    
    @Override
    public String toString() {
        return "Person Details = Id:" + id + ", Name:" + name +
         ", Gender:" + gender + ", Location:" + location;
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Person person1 = Person.createPerson();
        person1.setPerson(101, "nithin", 'm', "mysuru");
        System.out.println(person1); // System.out.print(person.toString());
        
        Person person2 = Person.createPerson();
        System.out.println(person2); // System.out.print(person.toString());
        person2.setPerson(102, "aadya", 'f', "mysuru");
        System.out.println(person1); // System.out.print(person.toString());
    }
}

Output:
Person object is created
Person Details = Id:101, Name:nithin, Gender:m, Location:mysuru
Person Details = Id:101, Name:nithin, Gender:m, Location:mysuru
Person Details = Id:102, Name:aadya, Gender:f, Location:mysuru
-----------------------------------------------------------------------
main():
read T
String[] output = readData()
print output

readData(T):
	String output[T]
	for j from 1 to T do:
		Read N
		boys[N]
		girls[N]
		for i from 0 to N-1 do:
			read boys[i]
		for i from 0 to N-1 do:
			read girls[i]
		sort boys
		sort girls
		output[j] = checkArrangement(boys, girls)

String checkArrangement(boys, girls):
	ALGORITHM
--------------------------------------
N = 9
5  15  18  30  33  36  50  65  79

i = 8
j = 4
pivot = 33
----------------------------------------------
FUNCTION CALL STACK:

IR: Instruction reg
Holds address of the current instruction that is running

PC: Program counter
Holds addredd of next instruction to be executed

SP: Stack Pointer
Holds address of top frame in the stack

FP: Frame Pointer
Holds address of the frame of the function which currently running

Frame: Memory allocated to a function during runtime
Contents of a Frame:
local variables
function params
Called Function addresses
Return address

main(String... args) {
	String s = new String("aditya");
	p("I am at home");
	srikakulam();
	p('I am back home');
}

srikakulam() {
	int num = 10;
	p("I am at srikakulam");
	srikakulam();
	p('I am back at srikakulam');
}

annavaram(int num) {
	p('I came to the holy city of Annavaram');
}
---------------------------------------------------
DAY7 WEDNESDAY 18-06-2025

SEARCHING SORTING ALGORITHMS:

CRUD operations (5)
CRUP operations within memory
1. File I/P
2. JDBC (MySQL or MongoDb)
3. Hibernate (ORM)
4. SpringBoot (Postman)
5. HTML/CSS/JS
6. Bootstrap
7. ReactJs
8. Authentication
9. Multiple Entities (multiple tablesin the DB)

Linear Search (Sequential):
Given a list/array, we have to search for an element.
Count the frequency of an element (number of occurances)
Find Biggest element in an array
Find 2nd smallest element in an array
Find Biggest and smallest elements in an array.
Replace every occurance of X with Y in an Array
Remove the spaces or the value -1 in an array

CHARACTERISTICS OF BIG-OH:
1. Usually used to find WCE of an algorithm
2. It finds the efficiency in terms of N, where N is size of the i/p list. Thus it depends on N.
3. It considers the N to be very big.
4. Its job is not to give the exact efficiency, but to reveal/disclose the order in which the efficiency is. Thus we must remove the smaller chunk of values and also the constants.
5. However, we can also find the BCE and ACE as well.

BCE of Linear search is O(1)
ACE of Linear search is O(n)
WCE of Linear search is O(n)

Take the I/P size from the user.
Create the array with user given size.
Read the I/P data for the array.
Now Search an element
Print the O/P (position where the element is found [1st occurance])
-------------------------------------------------------------------
Problem statement:
ArrayList	Java Collection
Project Game
	Game
	Player
	
Player
	id, name, points, playerCount (static)
	
Player	POJO
PlayerOperations	CRUD
	Menu: create/add player, modifyPlayer, deletePlayer, listAllPlayers, searchPlayer, printPlayerCount
	Main() Menu based (do-while switch-case)

OLTP 
OLAP 

Interface: Type independent and abstract

Flyable
	fly()
	land()
	
Bird
Rocket
Helicopter
Aeroplace
Drone
--------------------------------------------------------------------------
Binary Search:

Pre-requisite: The i/p list must be sorted and we must also know the order of sorting.

Finding Worst Case Efficiency of Binary Search:

low < high

low <= high (LOOP CONDITION)

Finding WCE of Binary Search:

Assume number of iterations is X

n		n/2		n/4		n/8 .......     8     4     2     1
2(x-1)                                 2(3) 2(2) 2(1)   2(0)

2(x-1) = n
2(x)   = n
x = log(n)

x - y = z
x = y + z

x/y = z
y = x/z
-----------------------------------
for i from 0 to n-1 do:
	for j from 0 to n-i-1 do:
		compare consecutive elements
			swap
			
public void bubbleSirt(int[] array) {
	for(int i = 0; i < array.length-1; i++)
		for(int j = 0; j < array.length-i; j++)
			if(array[j] > array[j+1)
				swap(array[j], array[j+1);

best case scenario for almost all sorting techniques is the I/P array is already sorted (almost sorted)
BCE is O(n2)
WCE is O(n2)

worst case scenario for almost all sorting techniques is the I/P array is already sorted (almost sorted) but we are sorting in reserve order.

public void bubbleSirt(int[] array) {
	boolean sorted = true; // assume the i/p array is sorted
	for(int i = 0; i < array.length-1; i++) {
		for(int j = 0; j < array.length-i; j++)
			if(array[j] > array[j+1) {
				swap(array[j], array[j+1);
				sorted = false;
			}
		if(sorted)
			break;
	}
}
BCE of optimized Bubble sort is O(n)
WCE of optimized Bubble sort is O(n2)


5 4 3 2 1
4 3 2 1 5	4
3 2 1 4 5	3
2 1 3 4 5	2
1 2 3 4 5	1

(n-1) (n-2)

n(n+1)/2
21*11=231

1 + 2 + 3 ..... 18 19 20
1+20 = 21
2+19 = 21
3+18 = 21
n(n+1)/2
20*21/2=210

(n-1)(n-1+1)/2
4*5/2=10
----------------------------------------------------
Selection Sort:
1   2   4   4   6   6   9  10

small = 9
index = 7

------------------------------------------------------
Insertion Sort: (Decrease and Conquer)

23   11   3   13    7   5    29    17   23
23
11   23
3    11   23
3    11   13   23
3    7    11   13   23
3    5    7    11   13   23   29

public void insertionSort(float[] array) {
	for(int i = 1; i < array.length; i++) { // RUN through the elements of uns...
		element = array[i];
		j = i-1;
		while(element < array[j] && j >= 0) { // shifting the element in sorted array
			array[j+1] = array[j];
			j--;
		}
		array[j+1] = element;
		
WCE of insertion sort is O(n2)
BCE of Insertion sort is O(n)

We must avoid insertion sort for large sized arrays.
We should prefer insertion sort for smaller sized arrays.
We must used insertion sort when the array size is relatively small and it is some what already sorted.
-------------------------------------------
Partition.java

package programs;

import java.util.Arrays;
import java.util.Scanner;

public class Partition {
	
	public static int partitionArray(double[] array, int low, int high) {
		double pivot = array[high];
		int j = low;
		for(int i = low; i < high; i++) {
			if(array[i] < pivot) {
				double temp = array[i];
				array[i] = array[j];
				array[j] = temp;
				j++;
			}
		}
		double temp = array[high];
		array[high] = array[j];
		array[j] = temp;
		return j;
	}
}
-------------------------------
QuickSort.java

package programs;

import java.util.Arrays;

public class QuickSort {

	public static void quickSort(double[] array, int low, int high) {
		if(low < high) {
			int pivotIndex = Partition.partitionArray(array, low, high);
			quickSort(array, low, pivotIndex-1);
			quickSort(array, pivotIndex+1, high);
		}
	}
	
	public static void main(String[] args) {
		double[] array = {12, 35, 54, 1.2, 2.1, 1.5, 1.7, 1.11, 1.05, 1.55};
		System.out.println("Input Array: " + Arrays.toString(array));
		quickSort(array, 0, array.length-1);
		System.out.println("Sorted Array: " + Arrays.toString(array));
	}
}
---------------------------------------------
import java.util.Scanner;
public class Main {
    public static void main(String... args) {
        Scanner scan = new Scanner(System.in);
        int firstNum = scan.nextInt();
        int secondNum = scan.nextInt();
        int thirdNum = scan.nextInt();
        int fourthNum = scan.nextInt();
        
        int output1 = (firstNum + secondNum) * thirdNum;
        int output2 = (secondNum - fourthNum) / firstNum;
        int output3 = firstNum * fourthNum + thirdNum;
        int output4 = (firstNum + secondNum + thirdNum + fourthNum) / 2;
        System.out.println("Result of operation 1: " + output1);
        System.out.println("Result of operation 2: " + output2);
        System.out.println("Result of operation 3: " + output3);
        System.out.println("Result of operation 4: " + output4);
    }
} 
----------------------------------------------------
BITWISE OPERATORS:

& | ^ >> << ~

byte num1 = 29;
byte num2 = 18;
int result = num1 & num2;
System.out.println("Num1 and Num2 = " + result);
result = num1 & num2;
System.out.println("Num1 and Num2 = " + result);
result = num1 | num2;
System.out.println("Num1 and Num2 = " + result);
result = num1 ^ num2;
System.out.println("Num1 and Num2 = " + result);
result = ~num1;
System.out.println("Num1 and Num2 = " + result);
result = num1 << 3;
System.out.println("Num1 and Num2 = " + result);
result = num2 >> 2;
System.out.println("Num1 and Num2 = " + result);
---------------------------------------------------------

00011101
00010010
--------
00010000  &  16
00011111  |  31
00001111  ^  15
11100010  ~ -30  
            -24   num1 << 3
			  4   num1 >> 2

-128+98=-30

00011101
00111010
01110100
11101000

11101000
-128+64+32+8=-24

00010010
00001001
00000100

1. Flip the Nth bit of an int variable.
2. Flip all the bits of a variable and print its value.
3. Masking....
----------------------------------------------------
INTERVIEW SKILLS:

MCQ test:
MCSR:
1. Direct method
2. Indirect method
MCMR:
1. 
-ve Marking:
1. 25% .25

o1
o2
o3
o4
---------------------------------------------------------------
inputNum  = 8476273
outputNum = 8476327

in = 12345
on = 12354

in = 98765
on = NA
----------------------------------------

int num = scanner.nextInt();
String inputNum = String.valueOf(num);
char[] numAsArray = inputNum.toCharArray();
Arrays.sort(numAsArray);
inputNum = String(numAsArray);
int smallNum = Integer.ParseInt(inputNum);

StringBuilder sb = new StringBuilder(inputNum);
sb.reverse();
inputNum = sb.toString());
int bigNum = Integer.ParseInt(inputNum);

int differenceNum = bigNum - smallNum;
---------------------------------------------------------
Program skeleton: 
main() {
	input();
	
	output = logic();
	
	printOutput(output);
}
------------------------------------------------
package programs;

public class Person {
	public int id;
	public String name;
	
}

class Student extends Person {
	public String branch;
	public int semester;
	
}

class UserClass {
	public static void main() {
		Student student1 = new Student();
		Person person1 = new Person();
		Person person2 = new Student(); // Inheritance
		Student student2 = new Person();
		Object object1 = new Student();
		Object object2 = new Person();
		Object object3 = new Object();
		Person person3 = new Object();
		
		student1.semester = 4;
		student2.semester = 2;
		person3.name = "nithin";
		object1.name = "harish";
		object2.branch = "ece";
	}
}
--------------------------------------
package programs;

import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class PersonStack {
	private int stackPtr;
	List <Person> stack;
	
	{
		stackPtr = -1;
		stack = new ArrayList<>();
	}
	
	public void push(Person person) {
		stack.add(person);
		stackPtr++;
	}
	
	public Person pop() {
		if(stackPtr == -1) { // check if the stack is empty
			System.out.println("Stack is empty");
			return null; // to say that no element of the stack was popped
		}
		Person person = stack.get(stackPtr); // copy last ele in list
		stack.remove(stackPtr); // delete last ele from list
		stackPtr--;
		return person; // return the popped element from the stack
	}
	
	public void displayStack() {
		if(stack.isEmpty()) {
			System.out.println("Stack is empty");
			return;
		}
		System.out.printf("%-5s %s", "ID", "NAME");
		System.out.println("\n------------------");
		for(int i = stack.size()-1; i >= 0; i--) {
			Person person = stack.get(i);
			int id = person.getId();
			String name = person.getName();
			System.out.printf("%-5d %s\n", id, name);
		}
		System.out.println();
	}
	
	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		PersonStack personStack = new PersonStack();
		int choice = 0;
		int numberOfOperations = 10;
		do {
			System.out.print("1:Push 2:Pop 3:DisplayStack 4:Exit. \t Your choice? ");
		choice = scanner.nextInt();
		switch(choice) {
		case 1 : 
			System.out.println("Enter Id and Name of the Person:");
			int id = scanner.nextInt();
			String name = scanner.next();
			personStack.push(new Person(id, name));
			break;
		case 2 :
			Person person = personStack.pop();
			if(person != null)
				System.out.println("Popped Person is " + person);
			break;
		case 3 :
			personStack.displayStack();
			break;
		case 4 :
			personStack.stack = null;
			numberOfOperations = 0;
			break;
		default:
			System.out.println("Invalid choice enetered");
		}
		numberOfOperations--;
		}while(numberOfOperations >= 0);
		System.out.println("End of Program");
	}
}
---------------------------------------------------
DAY9 FRIDAY 20-06-2025

STEPS TO DOWNLOAD MYSQL:

Google Search: Download MySQL
Click on Link:   mysql.com/downloads
-> MySQL Community GPL Downloads 
-> MySQL Installer for Windows 
-> No thanks start my download
Note: Download the Latest version (8.0.3) and the Bigger Sized File (330 MB or so)

Steps to Install MySQL:
Choose Setup type as Custom -> Click Next
MySql Server + Mysql WorkBench + MySql Shell (Drag all these to right)
Do not select the check box -> Click Next
Click on Execute (Make sure that all 3 Apps are visible in "Installation") -> Click Next
Type and Networking -> Click Next
Product Config -> click Next -> Port Number is shown -> Click Next
Use Strong Password -> Click Next
Set the Password (Remember it) -> Click Next
Windows Service -> Click Next
Server File Permissions -> Click Next
Apply Config -> Click Execute
Successful Message -> Click Finish 
Product Config -> Click Next
Installation Complete -> Click Finish
Workbench Runs
Go to MysQl Folder -> server folder -> bin (Add path to Environment Vars)

cmd -> mysql --version

mysql -u root -p   (To force the mysql to prompt for password)

show databases;  // run this command
create database db1;
-------------------------------------------------------
DAY10 SATURDAY 21-06-2025

MCQ Test-1 Link:
https://docs.google.com/forms/d/1382u2m4NAkmzWgpx4UsW41W9hx2ucmFVSZcHjghAQ3o/edit
-----------------------------------------
Things To DO Next Week (21st Saturday till 29th Sunday):
1. Coding test on searching Sorting Techniques on 21st Saturday
2. Every day 2 problems (minimum) must be solved on CodeKata till 29th Sunday
3. Coding test on Linked Lists on Wednesday 25th June
4. Coding test on Random topics on Saturday 28th June 
--------------------------------------------------------------
Entity: Person
	id, name, loaction, gender, age
Entity:
	id, airline, source, destination, fare, duration, dateOfInception

byte, short, int, long
tinyint, smallint, int, bigint

$ mysql -u root -p  <Enter>
<Enter the password>

To make the mysql command (CLI) available every where, add the below path to Environment Variables.
C:\Program Files\MySQL\MySQL Server 8.0\bin

Win Search: Env
Click Environment variables button
Now double click Path (on top list)
Now Click New
Now paste the Path
Click Ok ok Ok

In Java (any language or backend) the entity names must be Student, Employee, Bus, Person, Flight
The same names respectively in DB must be students, employees, buses, people, flights

project		-		database
classes		-		tables
instance Vars		fields/columns
setters(conditions)	constraints

DDL (create, alter)
informations
	1. fields (name, DT, constraints)
	2. auto increment info

delete * from students;
	Only data (rows) of the table is deleted. No info is deleted
truncate table students;
	Data and the auto increment info is deleted (meta data remains)
drop table students;
	Delete everything (rows/data, meta data, auto increment data)

select * from students where name = "null";
	Checking if the student name is "null"
select * from students where name = null;
	Checking if the student name is the value present in the variable null
select * from students where name is null;
	Checking if name of the student is empty
select * from students where name is "null";
	Syntax Error
-------------------------
Person: id, name, loaction, gender, age
create table people(id int primary key auto_increment, name varchar(50) not null, location varchar(50), gender varchar(2), age smallint default(0));